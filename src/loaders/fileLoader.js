/**
 * @file 读取文件 FileLoader 模块
 * @author liuliang(liuliang@w3ctech.com)
 */

import findConfig from 'find-config';
import slash from 'slash';
import path from 'path';
import {
  base
} from '../configs';
import utilityToolFactory from '../utils/utilityToolFactory'

/**
 * FileLoader 模块
 * @module module:fileLoader
 * @exports module:fileLoader.FileLoader
 */
export default class FileLoader {
  /**
   * a static member, module:fileLoader.FileLoader.asset
   * @memberof FileLoader
   * @public
   * @static
   */
  static asset = {};
  /**
   * module:fileLoader.FileLoader#name
   * @memberof FileLoader.prototype
   * @public
   */
  name;
  /**
   * module:fileLoader.FileLoader#config
   * @memberof FileLoader#
   * @public
   */
  config;
  /**
   * create a fileLoader
   * @param {string} [name=default] - the field name of an object for configuration
   * @param {Object} baseConfig - the basic config, including the symbol of current environment
   * @param {string} baseConfig.env - the symbol of current environment
   * @public
   */
  constructor(name = 'default', { env }) {
    this.config = base.loadConfig(this.name = name, env);
  }
  /**
   * load asset
   * @instance
   * @memberof FileLoader
   * @public
   * @returns {?Object}
   */
  loadAsset() {
    const {
      statsFile
    } = this.config;

    const stats = findConfig.require(statsFile, {
      home: false
    });

    return stats ? stats : null;
  }
  /**
   * get asset
   * @memberof FileLoader.prototype
   * @public
   * @returns {Object}
   */
  getAsset() {
    const {
      config: {
        isCache
      } = {},
      name
    } = this;

    if (!isCache) return this.loadAsset();
    if (!FileLoader.asset[name]) FileLoader.asset[name] = this.loadAsset();
    return FileLoader.asset[name];
  }
  /**
   * the filter using the value of ignore field for chunks
   * @memberof FileLoader#
   * @public
   * @param {Object[]} chunks - the list of chunk generated by webpack
   * @returns {Object}
   */
  chunksFilter(chunks) {
    const {
      ignores
    } = this.config;

    return chunks.filter(({ name }) => !ignores.some(ignore => new RegExp(ignore, 'gi').test(name))).map(chunk => this.getChunkUrl(chunk));
  }
  /**
   * get the url of chunk
   * @instance
   * @memberof FileLoader
   * @public
   * @param {Object} chunk - chunk generated by webpack
   * @returns {string}
   */
  getChunkUrl(chunk) {
    const {
      publicPath,
      name
    } = chunk;

    if (publicPath) return publicPath;

    const {
      bundleDirName
    } = this.config;
    const bundlePath = findConfig(name, {
      home: false,
      cwd: path.join('www', bundleDirName)
    });
    const wwwPath = findConfig('www', {
      home: false
    })

    return `/${slash(path.relative(wwwPath, bundlePath))}`;
  }
  /**
   * get bundle
   * @memberof FileLoader.prototype
   * @public
   * @param {string} bundleName - the name of bundle
   * @returns {Object|Error}
   */
  async getBundle(bundleName) {
    const self = this;
    const {
      isDebug,
      timeoutThreshold,
      pollInterval
    } = this.config;
    let asset = this.getAsset();

    if (isDebug) {
      const outputsGenerator = async function* () {
        try {
          while (true) {
            await utilityToolFactory.wait(pollInterval);
            yield self.getAsset();
          }
        } catch {

        }
      };
      const startTime = +new Date;
      const outputs = outputsGenerator();

      for await (const output of outputs) {
        if (new Date - startTime >= timeoutThreshold) {
          outputs.throw(new Error('compile timeout'));
        }
        if (output.status === 'done') {
          asset = output;
          break;
        }
      }
    }

    switch (asset.status) {
      case 'done': {
        const chunks = asset.chunks[bundleName];

        if (!chunks) {
          return new Error('chunks not found');
        }

        return this.chunksFilter(chunks);
      }
      case 'error': {
        return new Error('compile error');
      }
    }
  }
}
